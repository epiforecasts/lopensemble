#' @title Make mixture model from predictive samples
#'
#' @description
#' The function takes a data.frame with predictive samples generated from
#' different models as well as weights corresponding to these models as input.
#' It then returns predictive samples from a mixture model
#' generated by stacking the original models using these weights.
#'
#'
#' @param data a data.frame with the following entries:
#' \itemize{
#'   \item observed, the true observed values (optional)
#'   \item predicted, predicted values corresponding to the true values in
#'   observed
#'   \item model, the name of the model used to generate the correspondig
#'   predictions
#'   \item geography (optional), the regions for which predictions are
#'   generated. If geography is missing, it will be assumed there are no
#'   geographical differenes to take into account. Internally, regions will
#'   be ordered alphabetically
#'   \item date (the date of the corresponding prediction / true value). Also
#'   works with numbers to indicate timesteps
#' }
#' @param weights stacking weights used to combine the original model to a
#' mixture model. If NULL (default), weights will first be estimated using
#' [crps_weights()].
#'
#' @param ... any additional parameters to pass to [crps_weights()] if `weights`
#' is NULL.
#'
#' @return data.frame with samples from the mixture model. The following
#' columns are returned:
#' \itemize{
#'   \item observed, the true observed values, if they were given as input
#'   \item predicted, predicted values corresponding to the true values in
#'   observed
#'   \item model, the name of the model used to generate the correspondig
#'   predictions
#'   \item geography (optional), the regions for which predictions are
#'   generated. If geography is missing, it will be assumed there are no
#'   geographical differenes to take into account. Internally, regions will
#'   be ordered alphabetically
#'   \item date (the date of the corresponding prediction / true value). Also
#'   works with numbers to indicate timesteps
#' }
#' @examples
#' \dontrun{
#' library("data.table")
#' data <- setDT(example_data)
#' weights <- c(0.2, 0.3, 0.4, 0.1)
#' mix <- mixture_from_samples(data, weights = weights)
#' }
#'
#' @importFrom data.table `:=` setDT dcast.data.table setnames .SD
#' @export
#'
#' @references
#'
#' Using Stacking to Average Bayesian Predictive Distributions,
#' Yuling Yao, Aki Vehtari, Daniel Simpson, and Andrew Gelman, 2018,
#' Bayesian Analysis 13, Number 3, pp. 917â€“1003
#'

mixture_from_samples <- function(data,
                                 weights = NULL,
                                 ...) {
  data.table::setDT(data)

  # check if geography exists. if not, create a region
  if (!("geography" %in% names(data))) {
    data <- data[, geography := "Endor"]
    no_region <- TRUE
  } else {
    no_region <- FALSE
  }

  if (is.null(weights)) {
    weights <- crps_weights(data, ...)
  }

  # get models
  models <- unique(data$model)

  # number of predictive samples
  s <- max(data$sample_id)

  # function to draw from the individual models
  draw <- function(dat, weights, s, models) {
    # get an integer value of how many samples to draw from each model
    # note: instead of a rounding with preserved sum we might want to add
    # some randomness in where we round up so that there is no systematic bias
    num_draws <- round_with_preserved_sum(s * weights)

    # draw from individual models
    # note: maybe switch to purrr here
    mixture_vector <- sapply(seq_along(num_draws),
      FUN = function(i) {
        sample(
          x = dat[, get(..models[i])],
          size = num_draws[i]
        )
      }
    )
    return(do.call(c, mixture_vector))
  }

  # from long to wide format
  # keep observed if it was provided
  cols <- setdiff(colnames(data), c("predicted", "model"))
  dt_wide <- data.table::dcast.data.table(
    data,
    as.formula(paste0(paste(cols, collapse = " + "), " ~ model")),
    value.var = "predicted"
  )

  # draw
  dt_wide[, CRPS_Mixture := draw(.SD, weights, s, models),
    by = setdiff(cols, c("observed", "sample_id"))
  ]

  # clean up formatting
  out <- dt_wide[, (models) := NULL]
  out[, model := "CRPS_Mixture"]
  data.table::setnames(out, "CRPS_Mixture", "predicted")

  # drop region column if there were none in the input data
  if (no_region) {
    out[, geography := NULL]
  }

  weights <- data.frame(model = models, weight = unname(weights))
  attr(out, "weights") <- weights

  return(out[])
}
