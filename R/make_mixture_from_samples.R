#' @title Make mixture model from predictive samples
#'
#' @description
#' The function takes a data.frame with predictive samples generated from 
#' different models as well as weights corresponding to these models as input. 
#' It then returns predictive samples from a mixture model
#' generated by stacking the original models using these weights. 
#' 
#' 
#' @param data a data.frame with the following entries: 
#' \itemize{
#'   \item y_obs, the true observed values (optional)
#'   \item y_pred, predicted values corresponding to the true values in y_obs
#'   \item model, the name of the model used to generate the correspondig 
#'   predictions
#'   \item geography (optional), the regions for which predictions are 
#'   generated. If geography is missing, it will be assumed there are no 
#'   geographical differenes to take into account. Internally, regions will
#'   be ordered alphabetically 
#'   \item date (the date of the corresponding prediction / true value). Also
#'   works with numbers to indicate timesteps
#' }
#' @param weights stacking weights used to combine the original model to a 
#' mixture model
#' 
#' @return data.frame with samples from the mixture model. The following 
#' columns are returned: 
#' \itemize{
#'   \item y_obs, the true observed values, if they were given as input
#'   \item y_pred, predicted values corresponding to the true values in y_obs
#'   \item model, the name of the model used to generate the correspondig 
#'   predictions
#'   \item geography (optional), the regions for which predictions are 
#'   generated. If geography is missing, it will be assumed there are no 
#'   geographical differenes to take into account. Internally, regions will
#'   be ordered alphabetically 
#'   \item date (the date of the corresponding prediction / true value). Also
#'   works with numbers to indicate timesteps
#' }
#' @examples
#' 
#' \dontrun{
#' data <- data.table::setDT(stackr::example_data)
#' 
#' weights <- stackr::crps_weights(data)
#' 
#' mix <- stackr::mixture_from_samples(data, weights = weights)
#' }
#' 
#' @importFrom data.table `:=` setDT dcast.data.table setnames
#' @export
#' 
#' @references 
#' 
#' Using Stacking to Average Bayesian Predictive Distributions, 
#' Yuling Yao , Aki Vehtari, Daniel Simpson, and Andrew Gelman, 2018, 
#' Bayesian Analysis 13, Number 3, pp. 917â€“1003
#'

mixture_from_samples <- function(data,
                                 weights = NULL) {
  
  data.table::setDT(data)
  
  # check if geography exists. if not, create a region
  if (!("geography" %in% names(data))) {
    data <- data[, geography := "Endor"]
    no_region <- TRUE
  } else {
    no_region <- FALSE
  }
  
  # get models
  models <- unique(data$model) 

  # number of predictive samples
  S <- max(data$sample_nr)
  
  # function to draw from the individual models
  draw <- function(dat, weights, S, models) {
    
    # get an integer value of how many samples to draw from each model
    # note: instead of a rounding with preserved sum we might want to add
    # some randomness in where we round up so that there is no systematic bias
    num_draws <- round_with_preserved_sum(S * weights)
    
    # draw from individual models
    # note: maybe switch to purrr here
    mixture_vector <- sapply(seq_along(num_draws), 
                             FUN = function(i) {
                               sample(x = dat[, get(..models[i])], 
                                      size = num_draws[i])
                             })
    return(do.call(c, mixture_vector))
  }
  
  # from long to wide format
  # keep y_obs if it was provided
  if (("y_obs" %in% names(data))) {
    dt_wide <- data.table::dcast.data.table(data, 
                                            geography + date + sample_nr + y_obs ~ model, 
                                            value.var = "y_pred")
  } else {
    dt_wide <- data.table::dcast.data.table(data, 
                                            geography + date + sample_nr ~ model, 
                                            value.var = "y_pred")
  }
  
  
  
  # draw 
  dt_wide[, CRPS_Mixture := draw(.SD, weights, S, models), 
          by = .(geography, date)]
  
  # clean up formatting
  out <- dt_wide[, (models) := NULL]
  out[, model := "CRPS_Mixture"]
  data.table::setnames(out, "CRPS_Mixture", "y_pred")
  
  # drop region column if there were none in the input data 
  if (no_region) {
    out[, geography := NULL]
  }
  
  return(out)
}

