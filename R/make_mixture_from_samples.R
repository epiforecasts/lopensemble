#' @title Create Mixture Model from Predictive Samples
#'
#' @description
#' The function takes a data.frame with predictive samples generated from 
#' different models as well as weights corresponding to these models as input. 
#' It then returns predictive samples from a mixture model
#' generated by stacking the original models using these weights. 
#' 
#' 
#' @param data a data.frame with the following entries: 
#' \itemize{
#'   \item y_obs, the true observed values (optional)
#'   \item y_pred, predicted values corresponding to the true values in y_obs
#'   \item model, the name of the model used to generate the corresponding 
#'   predictions
#'   \item geography (optional), the regions for which predictions are 
#'   generated. If geography is missing, it will be assumed there are no 
#'   geographical differenes to take into account. Internally, regions will
#'   be ordered alphabetically 
#'   \item date (the date of the corresponding prediction / true value). Also
#'   works with numbers to indicate timesteps
#' }
#' @param weights stacking weights used to combine the original model to a 
#' mixture model
#' 
#' @return data.frame with samples from the mixture model. The following 
#' columns are returned: 
#' \itemize{
#'   \item y_obs, the true observed values, if they were given as input
#'   \item y_pred, predicted values corresponding to the true values in y_obs
#'   \item model, the name of the model used to generate the correspondig 
#'   predictions
#'   \item geography (optional), the regions for which predictions are 
#'   generated. If geography is missing, it will be assumed there are no 
#'   geographical differenes to take into account. Internally, regions will
#'   be ordered alphabetically 
#'   \item date (the date of the corresponding prediction / true value). Also
#'   works with numbers to indicate timesteps
#' }
#' @examples
#' 
#' \dontrun{
#' data <- data.table::setDT(stackr::example_data)
#' 
#' weights <- stackr::crps_weights(data)
#' 
#' mix <- stackr::mixture_from_samples(data, weights = weights)
#' }
#' 
#' @importFrom data.table `:=` setDT dcast.data.table setnames
#' @export
#' 
#' @references 
#' 
#' Using Stacking to Average Bayesian Predictive Distributions, 
#' Yuling Yao, Aki Vehtari, Daniel Simpson, and Andrew Gelman, 2018, 
#' Bayesian Analysis 13, Number 3, pp. 917â€“1003
#'

mixture_from_samples <- function(data,
                                 weights = NULL) {
  
  # should weights be a named list? a data.table? 
  # or just mandate that everything is ordered alphabetically? 
  
  data.table::setDT(data)
  
  # check if geography exists. if not, create a region
  if (!("geography" %in% names(data))) {
    data <- data[, geography := "Endor"]
    no_region <- TRUE
  } else {
    no_region <- FALSE
  }
  
  # get models
  models <- unique(data$model) 
  
  # make data.table out of weights and merge with data
  w <- data.table::data.table(model = models, 
                              model_weight = weights)
  
  data <- merge(data, w)
  
  # function to draw from the individual models
  draw <- function(data) {
    
    # order by model and sample_nr
    tmp <- data[order(model, sample_nr)]
    
    # calculate number of observations to draw from each model
    draws <- tmp[, .(S = unique(S), 
                     model_weight = unique(model_weight)), by = model]
    
    draws[, n_draws := stackr:::round_with_preserved_sum(min(S) * model_weight)]
    draws[, c("S", "model_weight") := NULL]
    
    tmp <- merge(tmp, draws)
    
    out <- tmp[, .(mixture = sample(y_pred, unique(n_draws), replace = TRUE)), by = model]
    return(out$mixture)
  }
  
  # add column with information about max number of samples available
  # check number of samples available for all models
  data[, maxS := max(.N), by = .(model, geography, date)]
  # if it is not the same, take the minimum across the models
  data[, S := min(maxS), by = .(geography, date)]
  
  if (any(data$maxS < data$S)) {
    warning("The number of samples provided for at least one observation differs across models")
    
  }
  
  out <- data[, .(crps_mixture = draw(.SD)), by = .(geography, date)]
  out[, sample_nr := seq_len(.N), by = c("geography", "date")]
  out[, model := "crps_mixture"]
  data.table::setnames(out, "crps_mixture", "y_pred")
  
  # drop region column if there were none in the input data 
  if (no_region) {
    out[, geography := NULL]
  }
  
  return(out)
}




