% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stacking_weights_crps.R
\name{crps_weights}
\alias{crps_weights}
\title{Obtain CRPS stacking weights}
\usage{
crps_weights(data, lambda = NULL, gamma = NULL, dirichlet_alpha = 1.001)
}
\arguments{
\item{data}{a data.frame with the following entries: 
\itemize{
  \item y_obs, the true observed values
  \item y_pred, predicted values corresponding to the true values in y_obs
  \item model, the name of the model used to generate the correspondig 
  predictions
  \item geography (optional), the regions for which predictions are 
  generated. If geography is missing, it will be assumed there are no 
  geographical differenes to take into account. Internally, regions will
  be ordered alphabetically 
  \item date (the date of the corresponding prediction / true value). Also
  works with numbers to indicate timesteps
}}

\item{lambda}{weights given to timepoints. If \code{lamba} is \code{NULL}, 
the default gives more weight to recent time points with 
lambda[t] = 2 - (1 - t / T)^2. Note that elemeents of lambda need not 
necessarily sum up to one as the stan model automatically constraints 
the final weights to sum to one irrespective of lambda. 
\code{lambda = "equal"} uses equal weights}

\item{gamma}{weights given to regions. If \code{gamma} is \code{NULL} the 
default is equal weights for the regions. Weights are mapped to regions
alphabetically, so make sure that the the weights correspond to the 
regions in alphabetical order.}

\item{dirichlet_alpha}{prior for the weights. Default is 1.001}
}
\value{
returns a vector with the model weights
}
\description{
given true values and predictive samples from different models, 
`crps_weights` returns the stacking weights which produce the ensemble
that minimises the Continuos Ranked Probability Score (CRPS).
}
\examples{

\dontrun{
library(data.table)
splitdate <- as.Date("2020-03-28")
data <- data.table::setDT(stackr::example_data)

traindata <- data[date <= splitdate]
testdata <- data[date > splitdate]

weights <- stackr::crps_weights(traindata)

test_mixture <- stackr::mixture_from_samples(testdata, 
                                    weights = weights)
                                    
score_df <- data.table::rbindlist(list(testdata,test_mixture),
                                  fill = TRUE)

score_df[, crps := scoringutils::crps(unique(y_obs), t(y_pred)), 
         by = .(geography, model, date)]

score_df[, mean(crps), by = model][, setnames(.SD, "V1", "CRPS")]
}

}
\references{
Strictly Proper Scoring Rules, Prediction,and Estimation,
Tilmann Gneiting and Adrian E. Raftery, 2007, Journal of the American
Statistical Association, Volume 102, 2007 - Issue 477

Using Stacking to Average Bayesian Predictive Distributions, 
Yuling Yao , Aki Vehtari, Daniel Simpson, and Andrew Gelman, 2018, 
Bayesian Analysis 13, Number 3, pp. 917â€“1003
}
